#!/usr/bin/env python

import datetime
import importlib.util
import inspect
import traceback

import yaml

import dripline
import scarab

import logging
logger = logging.getLogger('dripline')
logger.setLevel(logging.DEBUG)

class Serve:
    def __init__(self):
        self.return_code = 0
        self.handler = logging.StreamHandler()
        self.handler.setLevel(logging.WARNING)
        logger.addHandler(self.handler)
        time_format = '%Y-%m-%dT%H:%M:%S.%fZ'
        base_format = '%(asctime)s{}[%(levelname)-8s] %(name)s(%(lineno)d) -> {}%(message)s'
        self._logging_format = None
        try:
            import colorlog
            modified_format = base_format.format('%(log_color)s', '%(purple)s')
            self._logging_format = colorlog.ColoredFormatter(modified_format, datefmt=time_format[:-4])
        except ImportError:
            modified_format = base_format.format(' ', '')
            self._logging_format = logging.Formatter(modified_format, time_format[:-4])
        self.handler.setFormatter(self._logging_format)

    def create_object(self, a_config, a_auth = None):
        logger.debug("creating object from:\n{}\n...".format(a_config))
        module_name = a_config.pop('module', 'Service')
        module_path = a_config.pop('module_path', False)
        extra_namespace = object()
        if module_path:
            try:
                spec = importlib.util.spec_from_file_location('extra_namespace', module_path)
                extra_namespace = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(extra_namespace)
            except IOError as e:
                logger.error("unable to load source from: {}".format(module_path))
                raise e
        module = None
        #first priority, if it is in the module_path provided (if any)
        if hasattr(extra_namespace, module_name):
            module = getattr(extra_namespace, module_name)
        #second priority, if it is in any extensions installed
        elif hasattr(dripline.extensions, module_name):
            module = getattr(dripline.extensions, module_name)
        ## Note: we only loop one layer down in the config file, this could possibly be made more generic
        else:
            for m in [getattr(dripline.extensions, i_mod) for i_mod in dir(dripline.extensions)]:
                if inspect.ismodule(m):
                    if hasattr(m, module_name):
                        module = getattr(m, module_name)
        if module is None: # continue above elifs
        #third priority, if it is part of the base set of implementations
            if hasattr(dripline.implementations, module_name):
                module = getattr(dripline.implementations, module_name)
        #fourth priority, if it is in core
            elif hasattr(dripline.core, module_name):
                module = getattr(dripline.core, module_name)
            else:
                raise NameError('no module "{}" in available namespaces'.format(module_name))
            
        if a_auth is not None:
            logger.debug("creating object with authentication")
            the_object = module( authentication_obj=a_auth, **a_config )
        else:
            the_object = module( **a_config )

        return the_object

    def run(self, the_app):
        try:
            self._run(the_app)
        except:
            logger.error("got an error...")
            logger.error("traceback was:\n{}".format(traceback.format_exc()))
            self.return_code = 100

    def _run(self, the_app):
        this_config_param = the_app.primary_config
        this_auth = the_app.auth

        verbosity = the_app.global_verbosity
        #print(f"verbosity is {verbosity}")
        self.handler.setLevel(verbosity)

        sig_handler = scarab.SignalHandler()

        # Prior to v4.8.0, service configuration information was nested within the `runtime-config` block
        # This deprecates that usage and moves everything within `runtime-config` to the top level of the configuration
        if 'runtime-config' in this_config_param:
            logger.warning('The configuration uses the deprecated \'runtime-config\' structure.  This usage is deprecated and will be removed in a future version.')
            logger.warning('Please update your configuration file by moving everything within \'runtime-config\' to the top level of your configuration.')
            runtime_config = this_config_param.remove('runtime-config')
            this_config_param.merge(runtime_config)

        logger.debug(f'Serve (Python) got this primary config:\n{this_config_param}')

        # Convert config to a dict
        this_config = this_config_param.to_python()

        # Remove the endpoints configuration before creating and configuring the service
        the_endpoints = this_config.pop("endpoints", [])

#        service_config = run_config.copy()
#        service_config.update({'config': this_config})
#        logger.info(f'service config: {service_config}')
#        logger.info(f'run config: {run_config}')

        # Create the service and register it with the signal handler
        the_service = self.create_object( this_config, this_auth )
        sig_handler.add_cancelable(the_service)
        logger.info('service built')

        all_endpoints = []
        for an_endpoint_conf in the_endpoints:
            an_endpoint = self.create_object(an_endpoint_conf)
            the_service.add_child( an_endpoint )
            all_endpoints.append(an_endpoint)
            if getattr(an_endpoint, 'log_interval', datetime.timedelta(seconds=0)) > datetime.timedelta(seconds=0):
                logger.debug("queue up start logging for '{}'".format(an_endpoint.name))
                an_endpoint.start_logging()

        logger.info("about to start the service")
        if not the_service.start():
            raise RuntimeError("There was a problem starting the service")

        logger.info("services started, now to listen")
        if not the_service.listen():
            raise RuntimeError("there was a problem listening for messages")

        logger.info("stopping the service")
        if not the_service.stop():
            raise RuntimeError("there was a problem stopping the service")


if __name__ == '__main__':
    # App object
    the_main = scarab.MainApp()

    # Default configuration for a Service
    the_main.default_config = dripline.core.ServiceConfig()
    # We want scheduling to be on
    the_main.default_config.add('enable_scheduling', scarab.ParamValue(True))

    # Add the default dripline authentication specification and CL options
    dripline.core.add_dripline_auth_spec(the_main)
    dripline.core.add_dripline_options(the_main)
    dripline.core.add_service_options(the_main)

    # Package version information
    the_main.set_version(dripline.core.get_version( "dripline-python" ))

    # Create the Serve object
    the_server = Serve()

    # Callback function that will run everything
    the_main.set_callback(lambda : the_server.run(the_main))

    # Execute the callback (done via CLI11_PARSE)
    import sys
    the_main.execute(sys.argv)

    sys.exit(the_server.return_code)
